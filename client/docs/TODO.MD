

# ğŸ“‹ å®¢æˆ·ç«¯å¾…å®Œå–„åŠŸèƒ½å’Œæ¨èåŠŸèƒ½åˆ†æ

## ğŸ”„ å¾…å®Œå–„çš„æ ¸å¿ƒåŠŸèƒ½

### 1. **é…ç½®ç®¡ç†ç³»ç»Ÿ** âš ï¸ **é«˜ä¼˜å…ˆçº§**

**å½“å‰çŠ¶æ€ï¼š** é…ç½®ç¡¬ç¼–ç åœ¨æºç ä¸­  
**é—®é¢˜ï¼š**
```cpp
// å½“å‰ç¡¬ç¼–ç é…ç½®
struct Lusp_AsioIpcConfig {
    std::string host = "127.0.0.1";  // ç¡¬ç¼–ç IP
    uint16_t port = 9000;            // ç¡¬ç¼–ç ç«¯å£
    size_t buffer_size = 1024;       // å›ºå®šç¼“å†²åŒº
    int reconnect_interval_ms = 1000; // å›ºå®šé‡è¿é—´éš”
};
```

**éœ€è¦æ·»åŠ ï¼š**
```cpp
// æ¨èçš„é…ç½®ç®¡ç†ç³»ç»Ÿ
class ClientConfigManager {
public:


struct UploadConfig {
    // ===================== åŸºç¡€ç½‘ç»œé…ç½® =====================
    std::string serverHost = "127.0.0.1";   // æœåŠ¡å™¨åœ°å€
    uint16_t    serverPort = 9000;          // æœåŠ¡å™¨ç«¯å£
    std::string uploadProtocol = "HTTP";    // ä¸Šä¼ åè®®: HTTP/FTP/gRPC/WebSocket
    
    // ===================== ä¸Šä¼ æ§åˆ¶ =====================
    uint32_t maxConcurrentUploads = 4;      // æœ€å¤§å¹¶å‘ä¸Šä¼ ä»»åŠ¡æ•°
    uint32_t chunkSize = 1024 * 1024;       // åˆ†å—å¤§å°ï¼ˆé»˜è®¤1MBï¼‰
    uint32_t timeoutSeconds = 30;           // å•ä¸ªè¯·æ±‚è¶…æ—¶æ—¶é—´
    uint32_t retryCount = 3;                // ä¸Šä¼ å¤±è´¥é‡è¯•æ¬¡æ•°
    uint32_t retryDelayMs = 1000;           // é‡è¯•é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    uint64_t maxUploadSpeed = 0;            // æœ€å¤§ä¸Šä¼ é€Ÿç‡ (bytes/s, 0=ä¸é™é€Ÿ)
    uint64_t maxFileSize = 0;               // é™åˆ¶å•æ–‡ä»¶æœ€å¤§å¤§å° (0=ä¸é™)

    // ===================== åŠŸèƒ½å¼€å…³ =====================
    bool enableResume = true;               // æ˜¯å¦å¯ç”¨æ–­ç‚¹ç»­ä¼ 
    bool enableCompression = false;         // æ˜¯å¦å¯¹åˆ†å—æ•°æ®å‹ç¼©
    bool enableChecksum = false;            // æ˜¯å¦å¯ç”¨å®Œæ•´æ€§æ ¡éªŒ (MD5/SHA256)
    bool overwrite = false;                 // æ˜¯å¦è¦†ç›–æœåŠ¡å™¨å·²å­˜åœ¨çš„æ–‡ä»¶
    bool enableMultipart = true;            // æ˜¯å¦å¯ç”¨å¤šéƒ¨åˆ†è¡¨å•ä¸Šä¼ 
    bool enableProgress = true;             // æ˜¯å¦å¯ç”¨è¿›åº¦å›è°ƒ

    // ===================== æ–‡ä»¶ç›¸å…³ =====================
    std::string targetDir = "/uploads";     // æœåŠ¡å™¨ç›®æ ‡ç›®å½•
    std::vector<std::string> excludePatterns; // æ’é™¤çš„æ–‡ä»¶æ¨¡å¼ (*.tmp, *.bak)

    // ===================== å®‰å…¨/è®¤è¯ =====================
    bool useSSL = false;                    // æ˜¯å¦å¯ç”¨ SSL/TLS
    std::string certFile;                   // å®¢æˆ·ç«¯è¯ä¹¦æ–‡ä»¶
    std::string privateKeyFile;             // ç§é’¥æ–‡ä»¶
    std::string caFile;                     // CA è¯ä¹¦è·¯å¾„
    bool verifyServer = true;               // æ˜¯å¦æ ¡éªŒæœåŠ¡å™¨è¯ä¹¦
    std::string authToken;                  // ä¸Šä¼ é‰´æƒ Token

    // ===================== æ—¥å¿— & è°ƒè¯• =====================
    std::string logLevel = "INFO";          // æ—¥å¿—çº§åˆ«: DEBUG/INFO/WARN/ERROR
    std::string logFilePath;                // æ—¥å¿—æ–‡ä»¶è·¯å¾„ (ä¸ºç©º=åªè¾“å‡ºåˆ°æ§åˆ¶å°)
    bool enableDetailedLog = false;         // æ˜¯å¦è¾“å‡ºè¯¦ç»†æ—¥å¿— (æ¯ä¸ªåˆ†å—/é‡è¯•)

    // ===================== æ‰©å±• =====================
    std::string clientVersion = "1.0.0";    // å®¢æˆ·ç«¯ç‰ˆæœ¬å·ï¼Œç”¨äºæœåŠ¡ç«¯è¯†åˆ«
    std::string userAgent = "Uploader/1.0"; // è‡ªå®šä¹‰ User-Agent (HTTPç±»åè®®)
};

    
    struct UIConfig {
        bool showProgressDetails = true;
        bool showSpeedInfo = true;
        bool autoStartUpload = true;
        std::string language = "zh-CN";
        std::string theme = "default";
    };
    
    bool loadFromFile(const std::string& configPath);
    bool saveToFile(const std::string& configPath);
    void setDefaults();
    
    UploadConfig& getUploadConfig() { return m_uploadConfig; }
    UIConfig& getUIConfig() { return m_uiConfig; }
    
private:
    UploadConfig m_uploadConfig;
    UIConfig m_uiConfig;
};
```

### 2. **é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶** âš ï¸ **é«˜ä¼˜å…ˆçº§**

**å½“å‰çŠ¶æ€ï¼š** åŸºç¡€çš„å¼‚å¸¸å¤„ç†ï¼Œç¼ºä¹å®Œå–„çš„é‡è¯•æœºåˆ¶  
**é—®é¢˜æºç ï¼š**
```cpp
void Lusp_AsioLoopbackIpcClient::try_reconnect() {
    socket_ = std::make_shared<asio::ip::tcp::socket>(io_context_);
    std::this_thread::sleep_for(std::chrono::milliseconds(config_.reconnect_interval_ms));
    connect();  // ç®€å•é‡è¿ï¼Œæ— é€€é¿ç­–ç•¥
}
```

**éœ€è¦æ·»åŠ ï¼š**
```cpp
class RetryManager {
public:
    struct RetryPolicy {
        uint32_t maxRetries = 3;
        uint32_t baseDelayMs = 1000;
        double backoffMultiplier = 2.0;  // æŒ‡æ•°é€€é¿
        uint32_t maxDelayMs = 30000;
    };
    
    template<typename Func>
    bool executeWithRetry(Func&& func, const RetryPolicy& policy) {
        uint32_t delay = policy.baseDelayMs;
        for (uint32_t attempt = 0; attempt < policy.maxRetries; ++attempt) {
            try {
                if (func()) return true;
            } catch (const std::exception& e) {
                logRetryAttempt(attempt, e.what());
            }
            
            if (attempt < policy.maxRetries - 1) {
                std::this_thread::sleep_for(std::chrono::milliseconds(delay));
                delay = std::min(static_cast<uint32_t>(delay * policy.backoffMultiplier), 
                               policy.maxDelayMs);
            }
        }
        return false;
    }
    
private:
    void logRetryAttempt(uint32_t attempt, const std::string& error);
};
```

### 3. **è¿›åº¦ç›‘æ§å’Œç»Ÿè®¡ç³»ç»Ÿ** âš ï¸ **ä¸­ä¼˜å…ˆçº§**

**å½“å‰çŠ¶æ€ï¼š** åŸºç¡€çš„è¿›åº¦å›è°ƒï¼Œç¼ºä¹è¯¦ç»†ç»Ÿè®¡  
**å½“å‰å®ç°ï¼š**
```cpp
// å½“å‰ç®€å•çš„è¿›åº¦å›è°ƒ
void onProgressUpdate(const std::string& filePath, int percentage, const std::string& status);
```

**éœ€è¦æ·»åŠ ï¼š**
```cpp
class UploadStatistics {
public:
    struct FileStats {
        std::string fileId;
        std::string filePath;
        uint64_t totalBytes;
        uint64_t uploadedBytes;
        double speedBps;                // å­—èŠ‚/ç§’
        std::chrono::steady_clock::time_point startTime;
        std::chrono::steady_clock::time_point lastUpdateTime;
        uint32_t retryCount;
        UploadState state;
    };
    
    struct GlobalStats {
        uint64_t totalFiles;
        uint64_t completedFiles;
        uint64_t failedFiles;
        uint64_t totalBytesTransferred;
        double averageSpeed;
        std::chrono::seconds estimatedTimeRemaining;
    };
    
    void updateFileProgress(const std::string& fileId, uint64_t uploadedBytes);
    void setFileCompleted(const std::string& fileId, bool success);
    FileStats getFileStats(const std::string& fileId) const;
    GlobalStats getGlobalStats() const;
    
private:
    std::unordered_map<std::string, FileStats> m_fileStats;
    mutable std::shared_mutex m_statsMutex;
    
    double calculateSpeed(const FileStats& stats) const;
    std::chrono::seconds calculateETA() const;
};
```

### 4. **æ–‡ä»¶éªŒè¯å’Œæ ¡éªŒç³»ç»Ÿ** âš ï¸ **ä¸­ä¼˜å…ˆçº§**

**å½“å‰çŠ¶æ€ï¼š** åŸºç¡€çš„MD5è®¡ç®—ï¼Œç¼ºä¹å®Œæ•´çš„æ–‡ä»¶éªŒè¯  
**å½“å‰å®ç°ï¼š**
```cpp
bool calculateFileMd5ValueInfo();  // ä»…è®¡ç®—MD5
```

**éœ€è¦æ·»åŠ ï¼š**
```cpp
class FileValidator {
public:
    enum class ValidationLevel {
        BASIC,      // æ–‡ä»¶å­˜åœ¨æ€§å’Œå¯è¯»æ€§
        CHECKSUM,   // MD5/SHA256æ ¡éªŒ
        CONTENT,    // æ–‡ä»¶å†…å®¹éªŒè¯
        FULL        // å®Œæ•´éªŒè¯
    };
    
    struct ValidationResult {
        bool isValid = false;
        std::string errorMessage;
        std::string fileHash;
        uint64_t fileSize;
        std::chrono::system_clock::time_point lastModified;
    };
    
    ValidationResult validateFile(const std::string& filePath, 
                                ValidationLevel level = ValidationLevel::BASIC);
    
    bool validateFileSize(const std::string& filePath, uint64_t maxSize);
    bool validateFileType(const std::string& filePath, 
                         const std::set<std::string>& allowedExtensions);
    bool validateFileAccess(const std::string& filePath);
    
private:
    std::string calculateSHA256(const std::string& filePath);
    bool isFileInUse(const std::string& filePath);
};
```

### 5. **ç½‘ç»œçŠ¶æ€ç›‘æ§** âš ï¸ **ä¸­ä¼˜å…ˆçº§**

**å½“å‰çŠ¶æ€ï¼š** åŸºç¡€çš„è¿æ¥çŠ¶æ€ï¼Œç¼ºä¹ç½‘ç»œè´¨é‡ç›‘æ§  
**éœ€è¦æ·»åŠ ï¼š**
```cpp
class NetworkMonitor {
public:
    struct NetworkStatus {
        bool isConnected = false;
        double latencyMs = 0.0;
        double packetLossRate = 0.0;
        double bandwidthMbps = 0.0;
        std::chrono::steady_clock::time_point lastCheck;
    };
    
    void startMonitoring(const std::string& targetHost, uint16_t port);
    void stopMonitoring();
    NetworkStatus getCurrentStatus() const;
    
    // å›è°ƒæ¥å£
    void setNetworkStateCallback(std::function<void(bool connected)> callback);
    void setQualityCallback(std::function<void(const NetworkStatus&)> callback);
    
private:
    std::thread m_monitorThread;
    std::atomic<bool> m_monitoring{false};
    NetworkStatus m_currentStatus;
    mutable std::mutex m_statusMutex;
    
    void monitorLoop();
    bool pingHost(const std::string& host, uint16_t port, double& latencyMs);
    double measureBandwidth();
};
```

## ğŸš€ æ¨èæ·»åŠ çš„åŠŸèƒ½

### 1. **æ–­ç‚¹ç»­ä¼ æ”¯æŒ** â­ **å¼ºçƒˆæ¨è**

```cpp
class ResumeManager {
public:
    struct UploadCheckpoint {
        std::string fileId;
        std::string filePath;
        uint64_t uploadedBytes;
        std::string serverToken;  // æœåŠ¡å™¨è¿”å›çš„ç»­ä¼ token
        std::chrono::system_clock::time_point timestamp;
        std::vector<uint32_t> uploadedChunks;  // å·²ä¸Šä¼ çš„åˆ†ç‰‡
    };
    
    bool saveCheckpoint(const UploadCheckpoint& checkpoint);
    std::optional<UploadCheckpoint> loadCheckpoint(const std::string& fileId);
    void removeCheckpoint(const std::string& fileId);
    
    std::vector<UploadCheckpoint> getAllCheckpoints();
    void cleanExpiredCheckpoints(std::chrono::hours maxAge = std::chrono::hours(24));
    
private:
    std::string getCheckpointPath(const std::string& fileId);
    bool isValidCheckpoint(const UploadCheckpoint& checkpoint);
};
```

### 2. **å¤šæœåŠ¡å™¨æ”¯æŒå’Œè´Ÿè½½å‡è¡¡** â­ **å¼ºçƒˆæ¨è**

```cpp
class ServerManager {
public:
    struct ServerInfo {
        std::string host;
        uint16_t port;
        uint32_t weight = 100;      // æƒé‡
        uint32_t maxConnections = 5;
        bool isActive = true;
        double avgLatency = 0.0;
        uint32_t errorCount = 0;
        std::chrono::steady_clock::time_point lastCheck;
    };
    
    void addServer(const ServerInfo& server);
    void removeServer(const std::string& host, uint16_t port);
    std::optional<ServerInfo> selectBestServer();
    
    void reportServerError(const std::string& host, uint16_t port);
    void reportServerSuccess(const std::string& host, uint16_t port, double latency);
    
    std::vector<ServerInfo> getAllServers() const;
    
private:
    std::vector<ServerInfo> m_servers;
    mutable std::shared_mutex m_serversMutex;
    
    double calculateServerScore(const ServerInfo& server) const;
    void updateServerHealth();
};
```

### 3. **ä¸Šä¼ é˜Ÿåˆ—ä¼˜åŒ–** â­ **æ¨è**

```cpp
class PriorityUploadQueue {
public:
    enum class Priority {
        LOW = 0,
        NORMAL = 1,
        HIGH = 2,
        URGENT = 3
    };
    
    struct UploadTask {
        std::string fileId;
        Lusp_SyncUploadFileInfo fileInfo;
        Priority priority = Priority::NORMAL;
        std::chrono::steady_clock::time_point deadline;  // æˆªæ­¢æ—¶é—´
        uint32_t retryCount = 0;
    };
    
    void push(const UploadTask& task);
    bool tryPop(UploadTask& task);
    bool waitAndPop(UploadTask& task, std::chrono::milliseconds timeout);
    
    void changePriority(const std::string& fileId, Priority newPriority);
    void cancelTask(const std::string& fileId);
    
    size_t size() const;
    size_t sizeByPriority(Priority priority) const;
    
private:
    using TaskQueue = std::priority_queue<UploadTask, std::vector<UploadTask>, TaskComparator>;
    TaskQueue m_queue;
    mutable std::mutex m_queueMutex;
    std::condition_variable m_condition;
    
    struct TaskComparator {
        bool operator()(const UploadTask& a, const UploadTask& b) const;
    };
};
```

### 4. **ç¼“å­˜å’Œé¢„å¤„ç†ç³»ç»Ÿ** â­ **æ¨è**

```cpp
class FilePreprocessor {
public:
    struct PreprocessResult {
        std::string fileHash;
        uint64_t compressedSize;
        std::vector<ChunkInfo> chunks;
        bool needsCompression = false;
        std::string tempFilePath;  // é¢„å¤„ç†åçš„ä¸´æ—¶æ–‡ä»¶
    };
    
    std::future<PreprocessResult> preprocessFile(const std::string& filePath);
    
    void setCompressionLevel(int level);  // 0-9
    void setChunkSize(uint32_t size);
    void enableDuplication(bool enable);  // å»é‡åŠŸèƒ½
    
private:
    ThreadPool m_threadPool;
    uint32_t m_chunkSize = 1024 * 1024;  // 1MB
    int m_compressionLevel = 6;
    bool m_enableDeduplication = true;
    
    PreprocessResult processFile(const std::string& filePath);
    std::vector<ChunkInfo> createChunks(const std::string& filePath);
    bool shouldCompress(const std::string& filePath, uint64_t fileSize);
};
```

### 5. **ç”¨æˆ·ç•Œé¢å¢å¼º** â­ **æ¨è**

```cpp
class EnhancedMainWindow : public MainWindow {
public:
    // æ·»åŠ çš„UIç»„ä»¶
    void setupAdvancedUI();
    
private slots:
    void onShowSettings();
    void onShowStatistics();
    void onShowUploadHistory();
    void onPauseResumeUpload();
    void onCancelUpload();
    void onRetryFailedUploads();
    
private:
    // æ–°å¢UIç»„ä»¶
    QTabWidget* m_tabWidget;
    QTreeView* m_uploadTreeView;      // æ ‘å½¢ä¸Šä¼ åˆ—è¡¨
    QProgressBar* m_globalProgressBar;
    QLabel* m_speedLabel;
    QLabel* m_etaLabel;
    QPushButton* m_pauseBtn;
    QPushButton* m_cancelBtn;
    QSystemTrayIcon* m_trayIcon;      // ç³»ç»Ÿæ‰˜ç›˜
    
    // é«˜çº§åŠŸèƒ½
    SettingsDialog* m_settingsDialog;
    StatisticsDialog* m_statisticsDialog;
    HistoryDialog* m_historyDialog;
    
    void setupSystemTray();
    void setupContextMenus();
    void updateGlobalProgress();
};
```

### 6. **æ’ä»¶ç³»ç»Ÿ** â­ **é«˜çº§åŠŸèƒ½**

```cpp
class PluginManager {
public:
    class IUploadPlugin {
    public:
        virtual ~IUploadPlugin() = default;
        virtual std::string getName() const = 0;
        virtual std::string getVersion() const = 0;
        
        virtual bool initialize() = 0;
        virtual void shutdown() = 0;
        
        // é’©å­å‡½æ•°
        virtual bool onPreUpload(UploadTask& task) = 0;
        virtual void onPostUpload(const UploadTask& task, bool success) = 0;
        virtual bool onFileValidation(const std::string& filePath) = 0;
    };
    
    bool loadPlugin(const std::string& pluginPath);
    void unloadPlugin(const std::string& pluginName);
    std::vector<std::string> getLoadedPlugins() const;
    
    // æ’ä»¶äº‹ä»¶åˆ†å‘
    void notifyPreUpload(UploadTask& task);
    void notifyPostUpload(const UploadTask& task, bool success);
    bool notifyFileValidation(const std::string& filePath);
    
private:
    std::unordered_map<std::string, std::unique_ptr<IUploadPlugin>> m_plugins;
    std::vector<HMODULE> m_loadedLibraries;  // Windows DLLå¥æŸ„
};
```

## ğŸ¯ å®ç°ä¼˜å…ˆçº§å»ºè®®

### ç¬¬ä¸€é˜¶æ®µï¼ˆç«‹å³å®ç°ï¼‰
1. **é…ç½®ç®¡ç†ç³»ç»Ÿ** - è§£å†³ç¡¬ç¼–ç é—®é¢˜
2. **é”™è¯¯å¤„ç†å¢å¼º** - æå‡ç¨³å®šæ€§
3. **åŸºç¡€çš„æ–­ç‚¹ç»­ä¼ ** - æ ¸å¿ƒåŠŸèƒ½

### ç¬¬äºŒé˜¶æ®µï¼ˆçŸ­æœŸå®ç°ï¼‰
1. **è¿›åº¦ç›‘æ§ä¼˜åŒ–** - æå‡ç”¨æˆ·ä½“éªŒ
2. **æ–‡ä»¶éªŒè¯ç³»ç»Ÿ** - ä¿è¯æ•°æ®å®Œæ•´æ€§
3. **UIç•Œé¢å¢å¼º** - æ·»åŠ æš‚åœ/å–æ¶ˆåŠŸèƒ½

### ç¬¬ä¸‰é˜¶æ®µï¼ˆä¸­æœŸå®ç°ï¼‰
1. **å¤šæœåŠ¡å™¨æ”¯æŒ** - æå‡å¯æ‰©å±•æ€§
2. **ç½‘ç»œç›‘æ§ç³»ç»Ÿ** - æ™ºèƒ½ä¸Šä¼ ç­–ç•¥
3. **ç¼“å­˜é¢„å¤„ç†** - æ€§èƒ½ä¼˜åŒ–

### ç¬¬å››é˜¶æ®µï¼ˆé•¿æœŸå®ç°ï¼‰
1. **æ’ä»¶ç³»ç»Ÿ** - æ‰©å±•æ€§
2. **é«˜çº§é˜Ÿåˆ—ç®¡ç†** - æ™ºèƒ½è°ƒåº¦
3. **ä¼ä¸šçº§åŠŸèƒ½** - æ—¥å¿—å®¡è®¡ã€æƒé™ç®¡ç†

è¿™äº›åŠŸèƒ½çš„æ·»åŠ å°†ä½¿å®¢æˆ·ç«¯ä»ä¸€ä¸ªåŸºç¡€çš„æ–‡ä»¶ä¸Šä¼ å·¥å…·å‡çº§ä¸ºä¼ä¸šçº§çš„æ–‡ä»¶ä¼ è¾“è§£å†³æ–¹æ¡ˆï¼