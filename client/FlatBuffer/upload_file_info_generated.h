// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_UPLOADFILEINFO_UPLOADCLIENT_SYNC_H_
#define FLATBUFFERS_GENERATED_UPLOADFILEINFO_UPLOADCLIENT_SYNC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace UploadClient {
namespace Sync {

struct FBS_SyncUploadFileInfo;
struct FBS_SyncUploadFileInfoBuilder;
struct FBS_SyncUploadFileInfoT;

struct FBS_HeartbeatMessage;
struct FBS_HeartbeatMessageBuilder;
struct FBS_HeartbeatMessageT;

enum FBS_SyncUploadStatusInf : int32_t {
  FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_COMPLETED = 0,
  FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_PENDING = 1,
  FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_UPLOADING = 2,
  FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_REJECTED = 3,
  FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_FAILED = 4,
  FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_UNDEFINED = 5,
  FBS_SyncUploadStatusInf_MIN = FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_COMPLETED,
  FBS_SyncUploadStatusInf_MAX = FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_UNDEFINED
};

inline const FBS_SyncUploadStatusInf (&EnumValuesFBS_SyncUploadStatusInf())[6] {
  static const FBS_SyncUploadStatusInf values[] = {
    FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_COMPLETED,
    FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_PENDING,
    FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_UPLOADING,
    FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_REJECTED,
    FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_FAILED,
    FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_UNDEFINED
  };
  return values;
}

inline const char * const *EnumNamesFBS_SyncUploadStatusInf() {
  static const char * const names[7] = {
    "FBS_SYNC_UPLOAD_STATUS_COMPLETED",
    "FBS_SYNC_UPLOAD_STATUS_PENDING",
    "FBS_SYNC_UPLOAD_STATUS_UPLOADING",
    "FBS_SYNC_UPLOAD_STATUS_REJECTED",
    "FBS_SYNC_UPLOAD_STATUS_FAILED",
    "FBS_SYNC_UPLOAD_STATUS_UNDEFINED",
    nullptr
  };
  return names;
}

inline const char *EnumNameFBS_SyncUploadStatusInf(FBS_SyncUploadStatusInf e) {
  if (::flatbuffers::IsOutRange(e, FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_COMPLETED, FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_UNDEFINED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFBS_SyncUploadStatusInf()[index];
}

enum FBS_SyncUploadFileTyped : int32_t {
  FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_DOCUMENT = 0,
  FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_IMAGE = 1,
  FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_VIDEO = 2,
  FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_AUDIO = 3,
  FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_ARCHIVE = 4,
  FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_CODE = 5,
  FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_UNDEFINED = 6,
  FBS_SyncUploadFileTyped_MIN = FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_DOCUMENT,
  FBS_SyncUploadFileTyped_MAX = FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_UNDEFINED
};

inline const FBS_SyncUploadFileTyped (&EnumValuesFBS_SyncUploadFileTyped())[7] {
  static const FBS_SyncUploadFileTyped values[] = {
    FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_DOCUMENT,
    FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_IMAGE,
    FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_VIDEO,
    FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_AUDIO,
    FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_ARCHIVE,
    FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_CODE,
    FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_UNDEFINED
  };
  return values;
}

inline const char * const *EnumNamesFBS_SyncUploadFileTyped() {
  static const char * const names[8] = {
    "FBS_SYNC_UPLOADTYPE_DOCUMENT",
    "FBS_SYNC_UPLOADTYPE_IMAGE",
    "FBS_SYNC_UPLOADTYPE_VIDEO",
    "FBS_SYNC_UPLOADTYPE_AUDIO",
    "FBS_SYNC_UPLOADTYPE_ARCHIVE",
    "FBS_SYNC_UPLOADTYPE_CODE",
    "FBS_SYNC_UPLOADTYPE_UNDEFINED",
    nullptr
  };
  return names;
}

inline const char *EnumNameFBS_SyncUploadFileTyped(FBS_SyncUploadFileTyped e) {
  if (::flatbuffers::IsOutRange(e, FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_DOCUMENT, FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_UNDEFINED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFBS_SyncUploadFileTyped()[index];
}

enum FBS_SyncFileExistPolicy : int32_t {
  FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_OVERWRITE = 0,
  FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_SKIP = 1,
  FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_RENAME = 2,
  FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_UNDEFINED = 3,
  FBS_SyncFileExistPolicy_MIN = FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_OVERWRITE,
  FBS_SyncFileExistPolicy_MAX = FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_UNDEFINED
};

inline const FBS_SyncFileExistPolicy (&EnumValuesFBS_SyncFileExistPolicy())[4] {
  static const FBS_SyncFileExistPolicy values[] = {
    FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_OVERWRITE,
    FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_SKIP,
    FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_RENAME,
    FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_UNDEFINED
  };
  return values;
}

inline const char * const *EnumNamesFBS_SyncFileExistPolicy() {
  static const char * const names[5] = {
    "FBS_SYNC_FILE_EXIST_POLICY_OVERWRITE",
    "FBS_SYNC_FILE_EXIST_POLICY_SKIP",
    "FBS_SYNC_FILE_EXIST_POLICY_RENAME",
    "FBS_SYNC_FILE_EXIST_POLICY_UNDEFINED",
    nullptr
  };
  return names;
}

inline const char *EnumNameFBS_SyncFileExistPolicy(FBS_SyncFileExistPolicy e) {
  if (::flatbuffers::IsOutRange(e, FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_OVERWRITE, FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_UNDEFINED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFBS_SyncFileExistPolicy()[index];
}

enum FBS_HeartbeatType : int8_t {
  FBS_HeartbeatType_FBS_HEARTBEAT_PING = 0,
  FBS_HeartbeatType_FBS_HEARTBEAT_PONG = 1,
  FBS_HeartbeatType_MIN = FBS_HeartbeatType_FBS_HEARTBEAT_PING,
  FBS_HeartbeatType_MAX = FBS_HeartbeatType_FBS_HEARTBEAT_PONG
};

inline const FBS_HeartbeatType (&EnumValuesFBS_HeartbeatType())[2] {
  static const FBS_HeartbeatType values[] = {
    FBS_HeartbeatType_FBS_HEARTBEAT_PING,
    FBS_HeartbeatType_FBS_HEARTBEAT_PONG
  };
  return values;
}

inline const char * const *EnumNamesFBS_HeartbeatType() {
  static const char * const names[3] = {
    "FBS_HEARTBEAT_PING",
    "FBS_HEARTBEAT_PONG",
    nullptr
  };
  return names;
}

inline const char *EnumNameFBS_HeartbeatType(FBS_HeartbeatType e) {
  if (::flatbuffers::IsOutRange(e, FBS_HeartbeatType_FBS_HEARTBEAT_PING, FBS_HeartbeatType_FBS_HEARTBEAT_PONG)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFBS_HeartbeatType()[index];
}

struct FBS_SyncUploadFileInfoT : public ::flatbuffers::NativeTable {
  typedef FBS_SyncUploadFileInfo TableType;
  UploadClient::Sync::FBS_SyncUploadFileTyped e_upload_file_typed = UploadClient::Sync::FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_DOCUMENT;
  std::string s_lan_client_device{};
  uint64_t s_sync_file_size_value = 0;
  std::string s_file_full_name_value{};
  std::string s_only_file_name_value{};
  std::string s_file_record_time_value{};
  std::string s_file_md5_value_info{};
  UploadClient::Sync::FBS_SyncFileExistPolicy e_file_exist_policy = UploadClient::Sync::FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_OVERWRITE;
  std::string s_auth_token_values{};
  uint64_t u_upload_time_stamp = 0;
  UploadClient::Sync::FBS_SyncUploadStatusInf e_upload_status_inf = UploadClient::Sync::FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_COMPLETED;
  std::string s_description_info{};
  uint64_t enqueue_time_ms = 0;
};

struct FBS_SyncUploadFileInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FBS_SyncUploadFileInfoT NativeTableType;
  typedef FBS_SyncUploadFileInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_E_UPLOAD_FILE_TYPED = 4,
    VT_S_LAN_CLIENT_DEVICE = 6,
    VT_S_SYNC_FILE_SIZE_VALUE = 8,
    VT_S_FILE_FULL_NAME_VALUE = 10,
    VT_S_ONLY_FILE_NAME_VALUE = 12,
    VT_S_FILE_RECORD_TIME_VALUE = 14,
    VT_S_FILE_MD5_VALUE_INFO = 16,
    VT_E_FILE_EXIST_POLICY = 18,
    VT_S_AUTH_TOKEN_VALUES = 20,
    VT_U_UPLOAD_TIME_STAMP = 22,
    VT_E_UPLOAD_STATUS_INF = 24,
    VT_S_DESCRIPTION_INFO = 26,
    VT_ENQUEUE_TIME_MS = 28
  };
  UploadClient::Sync::FBS_SyncUploadFileTyped e_upload_file_typed() const {
    return static_cast<UploadClient::Sync::FBS_SyncUploadFileTyped>(GetField<int32_t>(VT_E_UPLOAD_FILE_TYPED, 0));
  }
  const ::flatbuffers::String *s_lan_client_device() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S_LAN_CLIENT_DEVICE);
  }
  uint64_t s_sync_file_size_value() const {
    return GetField<uint64_t>(VT_S_SYNC_FILE_SIZE_VALUE, 0);
  }
  const ::flatbuffers::String *s_file_full_name_value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S_FILE_FULL_NAME_VALUE);
  }
  const ::flatbuffers::String *s_only_file_name_value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S_ONLY_FILE_NAME_VALUE);
  }
  const ::flatbuffers::String *s_file_record_time_value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S_FILE_RECORD_TIME_VALUE);
  }
  const ::flatbuffers::String *s_file_md5_value_info() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S_FILE_MD5_VALUE_INFO);
  }
  UploadClient::Sync::FBS_SyncFileExistPolicy e_file_exist_policy() const {
    return static_cast<UploadClient::Sync::FBS_SyncFileExistPolicy>(GetField<int32_t>(VT_E_FILE_EXIST_POLICY, 0));
  }
  const ::flatbuffers::String *s_auth_token_values() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S_AUTH_TOKEN_VALUES);
  }
  uint64_t u_upload_time_stamp() const {
    return GetField<uint64_t>(VT_U_UPLOAD_TIME_STAMP, 0);
  }
  UploadClient::Sync::FBS_SyncUploadStatusInf e_upload_status_inf() const {
    return static_cast<UploadClient::Sync::FBS_SyncUploadStatusInf>(GetField<int32_t>(VT_E_UPLOAD_STATUS_INF, 0));
  }
  const ::flatbuffers::String *s_description_info() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S_DESCRIPTION_INFO);
  }
  uint64_t enqueue_time_ms() const {
    return GetField<uint64_t>(VT_ENQUEUE_TIME_MS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_E_UPLOAD_FILE_TYPED, 4) &&
           VerifyOffset(verifier, VT_S_LAN_CLIENT_DEVICE) &&
           verifier.VerifyString(s_lan_client_device()) &&
           VerifyField<uint64_t>(verifier, VT_S_SYNC_FILE_SIZE_VALUE, 8) &&
           VerifyOffset(verifier, VT_S_FILE_FULL_NAME_VALUE) &&
           verifier.VerifyString(s_file_full_name_value()) &&
           VerifyOffset(verifier, VT_S_ONLY_FILE_NAME_VALUE) &&
           verifier.VerifyString(s_only_file_name_value()) &&
           VerifyOffset(verifier, VT_S_FILE_RECORD_TIME_VALUE) &&
           verifier.VerifyString(s_file_record_time_value()) &&
           VerifyOffset(verifier, VT_S_FILE_MD5_VALUE_INFO) &&
           verifier.VerifyString(s_file_md5_value_info()) &&
           VerifyField<int32_t>(verifier, VT_E_FILE_EXIST_POLICY, 4) &&
           VerifyOffset(verifier, VT_S_AUTH_TOKEN_VALUES) &&
           verifier.VerifyString(s_auth_token_values()) &&
           VerifyField<uint64_t>(verifier, VT_U_UPLOAD_TIME_STAMP, 8) &&
           VerifyField<int32_t>(verifier, VT_E_UPLOAD_STATUS_INF, 4) &&
           VerifyOffset(verifier, VT_S_DESCRIPTION_INFO) &&
           verifier.VerifyString(s_description_info()) &&
           VerifyField<uint64_t>(verifier, VT_ENQUEUE_TIME_MS, 8) &&
           verifier.EndTable();
  }
  FBS_SyncUploadFileInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FBS_SyncUploadFileInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FBS_SyncUploadFileInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FBS_SyncUploadFileInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FBS_SyncUploadFileInfoBuilder {
  typedef FBS_SyncUploadFileInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_e_upload_file_typed(UploadClient::Sync::FBS_SyncUploadFileTyped e_upload_file_typed) {
    fbb_.AddElement<int32_t>(FBS_SyncUploadFileInfo::VT_E_UPLOAD_FILE_TYPED, static_cast<int32_t>(e_upload_file_typed), 0);
  }
  void add_s_lan_client_device(::flatbuffers::Offset<::flatbuffers::String> s_lan_client_device) {
    fbb_.AddOffset(FBS_SyncUploadFileInfo::VT_S_LAN_CLIENT_DEVICE, s_lan_client_device);
  }
  void add_s_sync_file_size_value(uint64_t s_sync_file_size_value) {
    fbb_.AddElement<uint64_t>(FBS_SyncUploadFileInfo::VT_S_SYNC_FILE_SIZE_VALUE, s_sync_file_size_value, 0);
  }
  void add_s_file_full_name_value(::flatbuffers::Offset<::flatbuffers::String> s_file_full_name_value) {
    fbb_.AddOffset(FBS_SyncUploadFileInfo::VT_S_FILE_FULL_NAME_VALUE, s_file_full_name_value);
  }
  void add_s_only_file_name_value(::flatbuffers::Offset<::flatbuffers::String> s_only_file_name_value) {
    fbb_.AddOffset(FBS_SyncUploadFileInfo::VT_S_ONLY_FILE_NAME_VALUE, s_only_file_name_value);
  }
  void add_s_file_record_time_value(::flatbuffers::Offset<::flatbuffers::String> s_file_record_time_value) {
    fbb_.AddOffset(FBS_SyncUploadFileInfo::VT_S_FILE_RECORD_TIME_VALUE, s_file_record_time_value);
  }
  void add_s_file_md5_value_info(::flatbuffers::Offset<::flatbuffers::String> s_file_md5_value_info) {
    fbb_.AddOffset(FBS_SyncUploadFileInfo::VT_S_FILE_MD5_VALUE_INFO, s_file_md5_value_info);
  }
  void add_e_file_exist_policy(UploadClient::Sync::FBS_SyncFileExistPolicy e_file_exist_policy) {
    fbb_.AddElement<int32_t>(FBS_SyncUploadFileInfo::VT_E_FILE_EXIST_POLICY, static_cast<int32_t>(e_file_exist_policy), 0);
  }
  void add_s_auth_token_values(::flatbuffers::Offset<::flatbuffers::String> s_auth_token_values) {
    fbb_.AddOffset(FBS_SyncUploadFileInfo::VT_S_AUTH_TOKEN_VALUES, s_auth_token_values);
  }
  void add_u_upload_time_stamp(uint64_t u_upload_time_stamp) {
    fbb_.AddElement<uint64_t>(FBS_SyncUploadFileInfo::VT_U_UPLOAD_TIME_STAMP, u_upload_time_stamp, 0);
  }
  void add_e_upload_status_inf(UploadClient::Sync::FBS_SyncUploadStatusInf e_upload_status_inf) {
    fbb_.AddElement<int32_t>(FBS_SyncUploadFileInfo::VT_E_UPLOAD_STATUS_INF, static_cast<int32_t>(e_upload_status_inf), 0);
  }
  void add_s_description_info(::flatbuffers::Offset<::flatbuffers::String> s_description_info) {
    fbb_.AddOffset(FBS_SyncUploadFileInfo::VT_S_DESCRIPTION_INFO, s_description_info);
  }
  void add_enqueue_time_ms(uint64_t enqueue_time_ms) {
    fbb_.AddElement<uint64_t>(FBS_SyncUploadFileInfo::VT_ENQUEUE_TIME_MS, enqueue_time_ms, 0);
  }
  explicit FBS_SyncUploadFileInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FBS_SyncUploadFileInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FBS_SyncUploadFileInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FBS_SyncUploadFileInfo> CreateFBS_SyncUploadFileInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UploadClient::Sync::FBS_SyncUploadFileTyped e_upload_file_typed = UploadClient::Sync::FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_DOCUMENT,
    ::flatbuffers::Offset<::flatbuffers::String> s_lan_client_device = 0,
    uint64_t s_sync_file_size_value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> s_file_full_name_value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> s_only_file_name_value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> s_file_record_time_value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> s_file_md5_value_info = 0,
    UploadClient::Sync::FBS_SyncFileExistPolicy e_file_exist_policy = UploadClient::Sync::FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_OVERWRITE,
    ::flatbuffers::Offset<::flatbuffers::String> s_auth_token_values = 0,
    uint64_t u_upload_time_stamp = 0,
    UploadClient::Sync::FBS_SyncUploadStatusInf e_upload_status_inf = UploadClient::Sync::FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_COMPLETED,
    ::flatbuffers::Offset<::flatbuffers::String> s_description_info = 0,
    uint64_t enqueue_time_ms = 0) {
  FBS_SyncUploadFileInfoBuilder builder_(_fbb);
  builder_.add_enqueue_time_ms(enqueue_time_ms);
  builder_.add_u_upload_time_stamp(u_upload_time_stamp);
  builder_.add_s_sync_file_size_value(s_sync_file_size_value);
  builder_.add_s_description_info(s_description_info);
  builder_.add_e_upload_status_inf(e_upload_status_inf);
  builder_.add_s_auth_token_values(s_auth_token_values);
  builder_.add_e_file_exist_policy(e_file_exist_policy);
  builder_.add_s_file_md5_value_info(s_file_md5_value_info);
  builder_.add_s_file_record_time_value(s_file_record_time_value);
  builder_.add_s_only_file_name_value(s_only_file_name_value);
  builder_.add_s_file_full_name_value(s_file_full_name_value);
  builder_.add_s_lan_client_device(s_lan_client_device);
  builder_.add_e_upload_file_typed(e_upload_file_typed);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FBS_SyncUploadFileInfo> CreateFBS_SyncUploadFileInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UploadClient::Sync::FBS_SyncUploadFileTyped e_upload_file_typed = UploadClient::Sync::FBS_SyncUploadFileTyped_FBS_SYNC_UPLOADTYPE_DOCUMENT,
    const char *s_lan_client_device = nullptr,
    uint64_t s_sync_file_size_value = 0,
    const char *s_file_full_name_value = nullptr,
    const char *s_only_file_name_value = nullptr,
    const char *s_file_record_time_value = nullptr,
    const char *s_file_md5_value_info = nullptr,
    UploadClient::Sync::FBS_SyncFileExistPolicy e_file_exist_policy = UploadClient::Sync::FBS_SyncFileExistPolicy_FBS_SYNC_FILE_EXIST_POLICY_OVERWRITE,
    const char *s_auth_token_values = nullptr,
    uint64_t u_upload_time_stamp = 0,
    UploadClient::Sync::FBS_SyncUploadStatusInf e_upload_status_inf = UploadClient::Sync::FBS_SyncUploadStatusInf_FBS_SYNC_UPLOAD_STATUS_COMPLETED,
    const char *s_description_info = nullptr,
    uint64_t enqueue_time_ms = 0) {
  auto s_lan_client_device__ = s_lan_client_device ? _fbb.CreateString(s_lan_client_device) : 0;
  auto s_file_full_name_value__ = s_file_full_name_value ? _fbb.CreateString(s_file_full_name_value) : 0;
  auto s_only_file_name_value__ = s_only_file_name_value ? _fbb.CreateString(s_only_file_name_value) : 0;
  auto s_file_record_time_value__ = s_file_record_time_value ? _fbb.CreateString(s_file_record_time_value) : 0;
  auto s_file_md5_value_info__ = s_file_md5_value_info ? _fbb.CreateString(s_file_md5_value_info) : 0;
  auto s_auth_token_values__ = s_auth_token_values ? _fbb.CreateString(s_auth_token_values) : 0;
  auto s_description_info__ = s_description_info ? _fbb.CreateString(s_description_info) : 0;
  return UploadClient::Sync::CreateFBS_SyncUploadFileInfo(
      _fbb,
      e_upload_file_typed,
      s_lan_client_device__,
      s_sync_file_size_value,
      s_file_full_name_value__,
      s_only_file_name_value__,
      s_file_record_time_value__,
      s_file_md5_value_info__,
      e_file_exist_policy,
      s_auth_token_values__,
      u_upload_time_stamp,
      e_upload_status_inf,
      s_description_info__,
      enqueue_time_ms);
}

::flatbuffers::Offset<FBS_SyncUploadFileInfo> CreateFBS_SyncUploadFileInfo(::flatbuffers::FlatBufferBuilder &_fbb, const FBS_SyncUploadFileInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FBS_HeartbeatMessageT : public ::flatbuffers::NativeTable {
  typedef FBS_HeartbeatMessage TableType;
  UploadClient::Sync::FBS_HeartbeatType type = UploadClient::Sync::FBS_HeartbeatType_FBS_HEARTBEAT_PING;
  uint32_t sequence = 0;
  uint64_t timestamp = 0;
  std::string client_name{};
  std::string client_version{};
  std::string payload{};
};

struct FBS_HeartbeatMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FBS_HeartbeatMessageT NativeTableType;
  typedef FBS_HeartbeatMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_SEQUENCE = 6,
    VT_TIMESTAMP = 8,
    VT_CLIENT_NAME = 10,
    VT_CLIENT_VERSION = 12,
    VT_PAYLOAD = 14
  };
  UploadClient::Sync::FBS_HeartbeatType type() const {
    return static_cast<UploadClient::Sync::FBS_HeartbeatType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t sequence() const {
    return GetField<uint32_t>(VT_SEQUENCE, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  const ::flatbuffers::String *client_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_NAME);
  }
  const ::flatbuffers::String *client_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_VERSION);
  }
  const ::flatbuffers::String *payload() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyOffset(verifier, VT_CLIENT_NAME) &&
           verifier.VerifyString(client_name()) &&
           VerifyOffset(verifier, VT_CLIENT_VERSION) &&
           verifier.VerifyString(client_version()) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyString(payload()) &&
           verifier.EndTable();
  }
  FBS_HeartbeatMessageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FBS_HeartbeatMessageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FBS_HeartbeatMessage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FBS_HeartbeatMessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FBS_HeartbeatMessageBuilder {
  typedef FBS_HeartbeatMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(UploadClient::Sync::FBS_HeartbeatType type) {
    fbb_.AddElement<int8_t>(FBS_HeartbeatMessage::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_sequence(uint32_t sequence) {
    fbb_.AddElement<uint32_t>(FBS_HeartbeatMessage::VT_SEQUENCE, sequence, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(FBS_HeartbeatMessage::VT_TIMESTAMP, timestamp, 0);
  }
  void add_client_name(::flatbuffers::Offset<::flatbuffers::String> client_name) {
    fbb_.AddOffset(FBS_HeartbeatMessage::VT_CLIENT_NAME, client_name);
  }
  void add_client_version(::flatbuffers::Offset<::flatbuffers::String> client_version) {
    fbb_.AddOffset(FBS_HeartbeatMessage::VT_CLIENT_VERSION, client_version);
  }
  void add_payload(::flatbuffers::Offset<::flatbuffers::String> payload) {
    fbb_.AddOffset(FBS_HeartbeatMessage::VT_PAYLOAD, payload);
  }
  explicit FBS_HeartbeatMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FBS_HeartbeatMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FBS_HeartbeatMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FBS_HeartbeatMessage> CreateFBS_HeartbeatMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UploadClient::Sync::FBS_HeartbeatType type = UploadClient::Sync::FBS_HeartbeatType_FBS_HEARTBEAT_PING,
    uint32_t sequence = 0,
    uint64_t timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> payload = 0) {
  FBS_HeartbeatMessageBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_payload(payload);
  builder_.add_client_version(client_version);
  builder_.add_client_name(client_name);
  builder_.add_sequence(sequence);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FBS_HeartbeatMessage> CreateFBS_HeartbeatMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UploadClient::Sync::FBS_HeartbeatType type = UploadClient::Sync::FBS_HeartbeatType_FBS_HEARTBEAT_PING,
    uint32_t sequence = 0,
    uint64_t timestamp = 0,
    const char *client_name = nullptr,
    const char *client_version = nullptr,
    const char *payload = nullptr) {
  auto client_name__ = client_name ? _fbb.CreateString(client_name) : 0;
  auto client_version__ = client_version ? _fbb.CreateString(client_version) : 0;
  auto payload__ = payload ? _fbb.CreateString(payload) : 0;
  return UploadClient::Sync::CreateFBS_HeartbeatMessage(
      _fbb,
      type,
      sequence,
      timestamp,
      client_name__,
      client_version__,
      payload__);
}

::flatbuffers::Offset<FBS_HeartbeatMessage> CreateFBS_HeartbeatMessage(::flatbuffers::FlatBufferBuilder &_fbb, const FBS_HeartbeatMessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline FBS_SyncUploadFileInfoT *FBS_SyncUploadFileInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FBS_SyncUploadFileInfoT>(new FBS_SyncUploadFileInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FBS_SyncUploadFileInfo::UnPackTo(FBS_SyncUploadFileInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = e_upload_file_typed(); _o->e_upload_file_typed = _e; }
  { auto _e = s_lan_client_device(); if (_e) _o->s_lan_client_device = _e->str(); }
  { auto _e = s_sync_file_size_value(); _o->s_sync_file_size_value = _e; }
  { auto _e = s_file_full_name_value(); if (_e) _o->s_file_full_name_value = _e->str(); }
  { auto _e = s_only_file_name_value(); if (_e) _o->s_only_file_name_value = _e->str(); }
  { auto _e = s_file_record_time_value(); if (_e) _o->s_file_record_time_value = _e->str(); }
  { auto _e = s_file_md5_value_info(); if (_e) _o->s_file_md5_value_info = _e->str(); }
  { auto _e = e_file_exist_policy(); _o->e_file_exist_policy = _e; }
  { auto _e = s_auth_token_values(); if (_e) _o->s_auth_token_values = _e->str(); }
  { auto _e = u_upload_time_stamp(); _o->u_upload_time_stamp = _e; }
  { auto _e = e_upload_status_inf(); _o->e_upload_status_inf = _e; }
  { auto _e = s_description_info(); if (_e) _o->s_description_info = _e->str(); }
  { auto _e = enqueue_time_ms(); _o->enqueue_time_ms = _e; }
}

inline ::flatbuffers::Offset<FBS_SyncUploadFileInfo> FBS_SyncUploadFileInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FBS_SyncUploadFileInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFBS_SyncUploadFileInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FBS_SyncUploadFileInfo> CreateFBS_SyncUploadFileInfo(::flatbuffers::FlatBufferBuilder &_fbb, const FBS_SyncUploadFileInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FBS_SyncUploadFileInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _e_upload_file_typed = _o->e_upload_file_typed;
  auto _s_lan_client_device = _o->s_lan_client_device.empty() ? 0 : _fbb.CreateString(_o->s_lan_client_device);
  auto _s_sync_file_size_value = _o->s_sync_file_size_value;
  auto _s_file_full_name_value = _o->s_file_full_name_value.empty() ? 0 : _fbb.CreateString(_o->s_file_full_name_value);
  auto _s_only_file_name_value = _o->s_only_file_name_value.empty() ? 0 : _fbb.CreateString(_o->s_only_file_name_value);
  auto _s_file_record_time_value = _o->s_file_record_time_value.empty() ? 0 : _fbb.CreateString(_o->s_file_record_time_value);
  auto _s_file_md5_value_info = _o->s_file_md5_value_info.empty() ? 0 : _fbb.CreateString(_o->s_file_md5_value_info);
  auto _e_file_exist_policy = _o->e_file_exist_policy;
  auto _s_auth_token_values = _o->s_auth_token_values.empty() ? 0 : _fbb.CreateString(_o->s_auth_token_values);
  auto _u_upload_time_stamp = _o->u_upload_time_stamp;
  auto _e_upload_status_inf = _o->e_upload_status_inf;
  auto _s_description_info = _o->s_description_info.empty() ? 0 : _fbb.CreateString(_o->s_description_info);
  auto _enqueue_time_ms = _o->enqueue_time_ms;
  return UploadClient::Sync::CreateFBS_SyncUploadFileInfo(
      _fbb,
      _e_upload_file_typed,
      _s_lan_client_device,
      _s_sync_file_size_value,
      _s_file_full_name_value,
      _s_only_file_name_value,
      _s_file_record_time_value,
      _s_file_md5_value_info,
      _e_file_exist_policy,
      _s_auth_token_values,
      _u_upload_time_stamp,
      _e_upload_status_inf,
      _s_description_info,
      _enqueue_time_ms);
}

inline FBS_HeartbeatMessageT *FBS_HeartbeatMessage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FBS_HeartbeatMessageT>(new FBS_HeartbeatMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FBS_HeartbeatMessage::UnPackTo(FBS_HeartbeatMessageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = sequence(); _o->sequence = _e; }
  { auto _e = timestamp(); _o->timestamp = _e; }
  { auto _e = client_name(); if (_e) _o->client_name = _e->str(); }
  { auto _e = client_version(); if (_e) _o->client_version = _e->str(); }
  { auto _e = payload(); if (_e) _o->payload = _e->str(); }
}

inline ::flatbuffers::Offset<FBS_HeartbeatMessage> FBS_HeartbeatMessage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FBS_HeartbeatMessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFBS_HeartbeatMessage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FBS_HeartbeatMessage> CreateFBS_HeartbeatMessage(::flatbuffers::FlatBufferBuilder &_fbb, const FBS_HeartbeatMessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FBS_HeartbeatMessageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _sequence = _o->sequence;
  auto _timestamp = _o->timestamp;
  auto _client_name = _o->client_name.empty() ? 0 : _fbb.CreateString(_o->client_name);
  auto _client_version = _o->client_version.empty() ? 0 : _fbb.CreateString(_o->client_version);
  auto _payload = _o->payload.empty() ? 0 : _fbb.CreateString(_o->payload);
  return UploadClient::Sync::CreateFBS_HeartbeatMessage(
      _fbb,
      _type,
      _sequence,
      _timestamp,
      _client_name,
      _client_version,
      _payload);
}

inline const UploadClient::Sync::FBS_SyncUploadFileInfo *GetFBS_SyncUploadFileInfo(const void *buf) {
  return ::flatbuffers::GetRoot<UploadClient::Sync::FBS_SyncUploadFileInfo>(buf);
}

inline const UploadClient::Sync::FBS_SyncUploadFileInfo *GetSizePrefixedFBS_SyncUploadFileInfo(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<UploadClient::Sync::FBS_SyncUploadFileInfo>(buf);
}

inline bool VerifyFBS_SyncUploadFileInfoBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<UploadClient::Sync::FBS_SyncUploadFileInfo>(nullptr);
}

inline bool VerifySizePrefixedFBS_SyncUploadFileInfoBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<UploadClient::Sync::FBS_SyncUploadFileInfo>(nullptr);
}

inline void FinishFBS_SyncUploadFileInfoBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UploadClient::Sync::FBS_SyncUploadFileInfo> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFBS_SyncUploadFileInfoBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UploadClient::Sync::FBS_SyncUploadFileInfo> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<UploadClient::Sync::FBS_SyncUploadFileInfoT> UnPackFBS_SyncUploadFileInfo(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<UploadClient::Sync::FBS_SyncUploadFileInfoT>(GetFBS_SyncUploadFileInfo(buf)->UnPack(res));
}

inline std::unique_ptr<UploadClient::Sync::FBS_SyncUploadFileInfoT> UnPackSizePrefixedFBS_SyncUploadFileInfo(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<UploadClient::Sync::FBS_SyncUploadFileInfoT>(GetSizePrefixedFBS_SyncUploadFileInfo(buf)->UnPack(res));
}

}  // namespace Sync
}  // namespace UploadClient

#endif  // FLATBUFFERS_GENERATED_UPLOADFILEINFO_UPLOADCLIENT_SYNC_H_
